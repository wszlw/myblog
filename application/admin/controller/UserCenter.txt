类的继承：

  某些类A具有的某些特性，另一个类B，也具有A类的所有特性并且也有自己的特性，此时我们就可以实现B类使用A类的特性信息并继续添加自己的一些特有的特征信息
  关键字是:extends
基本概念:
   继承：一个类从另一个已有的类获得其特性，称为继承
   派生：从一个已有的类产生一个新的类，称为派生
   也可以理解为：已有类为父类，新建类为子类，父类也叫基类，子类也叫派生类
   一个类只能从一个上一级类继承其特性 叫单继承
   多继承的话 就是继承他父类的父类 也就是爷爷类
访问（权限）修饰符
   public:公共的  protected:受保护的  private:私有的
   1.public:
      用该修饰符 可以在任意位置使用其中包括：
       1.某个类的内部
       2.某个类的外部
       3.某个类的具有具有继承关系的类的内部
     语法形式：
       对象->成员 一般
       类名::成员 静态
   2.protected:
      用该修饰符，可以在当前类或者当前类的上下级具有继承关系的类中访问
   3.private：
      用该修饰符，只能在其所在的类中访问
parent代表父类：
   通常用于在子类中调用父类的成员的时候使用 没有继承关系不能用parent
构造方法析构方法：
   子类中没有定义构造方法的时候，会自动调用父类的构造方法。因此实例化子类时，需按照父类的构造方法的形式进行
   子类定义了自己的构造方法，则不会调用父类的构造方法 但可以手动调用 parent::__construct();
   通常在子类很多时候在构造方法中都应该（需要）去调用父类的构造方法以节省代码，增加可读性
重写 override：
   重写又叫覆盖，就是将从父类继承下来的属性或方法重新定义--- 就是从新写  
   重写必须发生在继承里面
   注意：子类覆盖父类的方法，虽然可以去调用父类的同名方法去完成一定的工作。但不是必须的。也有可能父类的该方法所执行的结果并不适合子类，此时子类就去完全自己写了
   重写的基本要求:
      下级的访问控制权限应该不低于上级的访问控制权限
      上级：public(公共的) 下级只能是 public
      上级：protected(受保护的) 下级只能是 protected , public
      上级：private(私有的) 下级：private protected public  --- 实际此情况无意义 私有的不能覆盖，而是完全当做自己全新的
最终类final class ：
   如果某个类不希望对其进行扩展，则可以将其声明为“最终类”
   形式： 
         final  class  类名{ 。。。。类定义。。。。}
最终方法 final method:
   如果某个方法不希望被下级类覆盖，就可以对其生命为“最终方法”
   形式：
         final  function  方法名(){。。。。方法定义。。。。}

1.首先是public修饰符来修饰的函数，是指这个函数可以被其他的类来调用，也可以被自己类里的函数来调用。

2.再看protected修饰符来修饰的函数，是指这个函数可以被继承类调用，也可以被自己类里的函数调用，但不能被其他的类调用。

3.用private修饰符来修饰的函数，就具有更少的权限了，只能被自己类里的其他函数调用，其他的一概不能调用。

弱口令限制

很多用户在注册的时候，喜欢使用非常简单的密码，比如 123456 或者 qweasd 之类的。尤其在企业内部系统中，这种用户密码更是常见。但是，这类密码简直形同虚设，如此简单的用户密码，非常容易被恶意用户猜解，从而导致信息的泄露，对企业信息安全造成严重威胁。为了避免这种情况的发生，我们在新用户注册或用户重设密码的时候，往往会对用户密码复杂度做出一定的限制，比如要求用户密码必须同时包含数字、大写字母、小写字母、特殊符号四类字符中的至少三类，且密码位数不能低于8位。

注册验证

作为一个企业内部系统，我们往往不希望企业外部人员也能够注册成为用户，因为这很可能会导致企业内部信息的泄露。那么，如何保证外部人员无法注册呢？常见的手段是使用企业邮箱对注册人的身份进行验证。比如，用户在注册时，除了要用户输入用户名和密码以外，还需要用户输入其企业邮箱账号。用户提交注册表单后，系统验证其输入的邮箱账号是企业内部的合法邮箱账号，并向这个邮箱发一封注册验证邮件，其内包含一个随机生成的复杂链接，用户点击这个链接之后，才能完全注册成功。

加密存储密码

用户注册成功之后，系统需要将用户名和密码的相关信息写入数据库或类似介质，以便用户下次登录系统时查询验证。可是为了防备一些非常规的情况，我们往往不能直接明文存储用户的密码，而是用摘要算法对用户密码进行若干处理，再将摘要信息写入数据库中。比如，用户的原始密码是 hell0W0rld ,我们先用 MD5 算法对密码做摘要，得到摘要密文 17529cb075a386f08409f260bf0dfb8c ，然后再用用户的注册时间戳作为 salt 拼接到密文上，得到 17529cb075a386f08409f260bf0dfb8c1484547629852 ，再对这个字符串用 MD5 算法做摘要，得到密码摘要信息 6ee203a6a6c05a6f8f958c5be00b1313 ，最后我们将用户名、密码摘要信息、用户注册时间戳三个信息全部写入数据库中，以便将来验证用户身份。

这样的做法虽然看起来比较繁琐，但其安全性得到了比较高的保障。即使数据库中的密码信息被完全盗取，且用户的原始密码相对简单，面对加了随机salt且做过两次摘要的密码信息，想要猜解出原始密码也是非常困难的

验证码

暴力猜解是比较常见的用户信息猜解手段，简单点说，就是用程序反复尝试用不同的密码登录某个账户，直到成功为止。这种破解用户密码的方式，一方面增加了用户信息泄露的风险，另一方面也由于系统需要不断的查询数据库验证密码正确性，而大大增加了系统的资源消耗。为了防止这种情况，一般我们需要通过随机图片验证码来验证当前提交登录请求的是人而不是某种程序。而一般为了平衡用户体验和系统安全性两方面的要求，常见的做法是用户输错密码3次后再要求用户输入验证码。

失败次数

虽然我们加了图片验证码提高系统的安全性，但还是有一些比较高级的破解程序，可以正确识别出图片验证码的内容。所以，我们还需要加上尝试失败次数的限制，当用户尝试登录失败超过指定的次数之后，系统就会锁定该账号。一段时间内，无论用户是否输入正确的用户密码，系统都拒绝该账号的登录请求，必须找系统管理员手段解锁，或等待一段时间之后才能再次尝试。

找回密码

找回密码也是很常见的需求点。用户有时候真的会忘记自己的密码，这时，需要用户能够手动重置自己的密码。常见的做法是用户提交重置密码请求，系统向该用户的注册邮箱发一封密码重置邮件，内含一个随机生成的复杂链接，用户通过这个链接地址访问系统的密码重置页面来重置自己的密码。

HTTPS

用户在发起登录请求时，输入的账号和密码信息通过网络发往服务器，这些信息在发往服务器的过程中会经历非常多的网络节点，如果信息在传输过程中是明文状态，那么这些网络节点就都可以获取到用户的账号和密码信息，这将成为非常大的系统信息安全隐患。因此，对用户登录过程中的敏感信息进行加密传输是非常必要的。最常见的做法就是对登录请求用 HTTPS 协议代替 HTTP 协议。

跨平台特性
很多的系统都具有跨平台特性，比如 OA 系统，我们可以在 PC 上填写加班申请单，在手机浏览器上查看这个申请单的审批状态，而如果公司员工是在微信中访问 OA 系统的页面，OA 系统还会通过关联的微信账号让用户直接登录系统，免去了输入用户名密码的步骤，从而大大提高了用户操作的便利性。